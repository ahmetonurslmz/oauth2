const { errorResolver, successResolver, validationResolver } = require('../../../core/utils/resolvers');
const { validationResult } = require('express-validator');
const Client = require('../models/ClientModel');

const { findOrThrow } = require('../../../core/utils/mongoInterrogator');


const HashGeneratorService = require('../../../core/services/hashGenerator.service');
const JWTGeneratorService = require('../../../core/services/jwtGenerator.service');
const JwtVerificationService = require('../../../core/services/jwtVerification.service');

const validateClient = require('../../../core/services/validateClient.service');
const validateEntriesService = require('../../../core/services/validateEntries.service');


module.exports.generateServerKeys = async (req, res) => {
    const crypto = require('crypto');
    const { privateKey, publicKey } = crypto.generateKeyPairSync('rsa', {
        modulusLength: 2048,
        publicKeyEncoding: {
            type: 'spki',
            format: 'pem'
        },
        privateKeyEncoding: {
            type: 'pkcs8',
            format: 'pem'
        }
    });

    const fs = require('fs');
    fs.writeFile('id_rsa_priv.pem', privateKey, 'utf8', function (err) {
        if (err) return console.log(err);
        console.log('id_rsa_priv.pem was generated.');
    });


    fs.writeFile('id_rsa_pub.pem', publicKey, 'utf8', function (err) {
        if (err) return console.log(err);
        console.log('id_rsa_pub.pem was generated');
    });

    successResolver(res, {
        message: 'Server keys generated!',
    });
};


module.exports.verifyAccessToken = async (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        validationResolver(errors.array(), next);
    } else {
        try {
            const verificationInstance = new JwtVerificationService(req.body.access_token);
            const payload = verificationInstance.decrypt();

            // Today date is smaller than expiration date so that access token is valid.
            if ((new Date().getTime() - payload.exp) < 0) {
                const active = verificationInstance.verify();

                successResolver(res, {
                    data: {
                        active,
                        ...payload,
                    },
                });
            } else {
                const e = new Error();
                e.message = 'Access token has been expired!';
                e.field = 'access_token';
                e.code = 400;
                throw e;
            }
        } catch (e) {
            errorResolver(e, next);
        }
    }
};

/**
 * Works for only authorization code grant type
 * @param req
 * @param res
 * @param next
 * @returns {Promise<void>}
 */
module.exports.getAccessToken = async (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        validationResolver(errors.array(), next);
    } else {
        const { client_id, grant_type } = req.body;

        try {
            if (grant_type === 'authorization_code') {
                await validateClient(req, client_id, 'code');

                validateEntriesService('code', req);

                const { code } = req.body;

                const AuthorizationCode = require('../models/AuthorizationCodeModel');
                await AuthorizationCode.init();

                const AccessToken = require('../models/AccessTokenModel');
                await AccessToken.init();

                let authorizationCodeData;
                try {
                    authorizationCodeData = await findOrThrow(AuthorizationCode, {
                        code,
                        client_id,
                        is_active: true,
                        expiry_date: { $gt: new Date() } // if expiry date is higher than now date.
                    });
                } catch (e) {
                    // checks whether authorization code exists or not.
                    const { _id: authorization_code_id } = await findOrThrow(AuthorizationCode, { code });

                    // controls whether access token that generated by authorization code exists or not
                    const hasAccessToken = AccessToken.findOne({ authorization_code_id });
                    if (hasAccessToken) {
                        // disables access token that generated by authorization code to prevent attacks
                        await AccessToken.updateOne({ authorization_code_id }, { is_active: false });
                    }
                    throw e;
                }

                // generates access token
                const jwtTokenInstance = new JWTGeneratorService();
                const access_token = jwtTokenInstance.sign();

                // generates refresh token
                jwtTokenInstance.payload = jwtTokenInstance.getDateInformation(true);
                const refresh_token = jwtTokenInstance.sign();

                const newAccessToken = {
                    authorization_code_id: authorizationCodeData._id,
                    client_id,
                    grant_type,
                    access_token,
                    refresh_token,
                };

                const { _doc } = await AccessToken.create(newAccessToken);


                // disable authorization code
                await AuthorizationCode.updateOne({ code }, { is_active: false });

                successResolver(res, {
                    data: {
                        access_token,
                        token_type: _doc.token_type,
                        expires_in: _doc.expires_in,
                        refresh_token,
                    },
                    message: 'Access token generated!',
                });
            } else if (grant_type === 'password') {
                await validateClient(req, client_id, 'token');

                validateEntriesService(['username', 'password'], req);

                // Resource server control
                const { username, password } = req.body;

                // generates access token
                const jwtTokenInstance = new JWTGeneratorService();
                jwtTokenInstance.payload = { username };

                const access_token = jwtTokenInstance.sign();

                // generates refresh token
                jwtTokenInstance.payload = { username, ...jwtTokenInstance.getDateInformation(true)};
                const refresh_token = jwtTokenInstance.sign();

                const newAccessToken = {
                    authorization_code_id: null,
                    client_id,
                    grant_type,
                    access_token,
                    refresh_token,
                };

                const AccessToken = require('../models/AccessTokenModel');
                await AccessToken.init();

                const { _doc } = await AccessToken.create(newAccessToken);

                successResolver(res, {
                    data: {
                        access_token,
                        token_type: _doc.token_type,
                        expires_in: _doc.expires_in,
                        refresh_token,
                    },
                    message: 'Access token generated!',
                });
            } else {
                const e = new Error();
                e.message = 'The grant type is not supported yet!';
                e.code = 403;
                throw e;
            }
        } catch (e) {
            errorResolver(e, next);
        }
    }
};


module.exports.getAuthorizationCode = async (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        validationResolver(errors.array(), next);
    } else {
        const { client_id } = req.body;

        try {
            await validateClient(req, client_id, 'code');

            const HashGeneratorServiceInstance = new HashGeneratorService();
            const hash = HashGeneratorServiceInstance.generate();


            const AuthorizationCode = require('../models/AuthorizationCodeModel');
            await AuthorizationCode.init();

            const PERIOD_OF_VALIDITY = 10; // minutes

            // generates authorization code's expiry date by adding period of validity minutes to now date.
            const expiry_date = new Date();
            expiry_date.setMinutes(expiry_date.getMinutes() + PERIOD_OF_VALIDITY);


            const newAuthorizationCode = {
                client_id,
                code: hash,
                expiry_date,
            };

            try {
                const { _doc } = await AuthorizationCode.create(newAuthorizationCode);
                successResolver(res, {
                    data: _doc,
                    message: 'Authorization code generated!',
                });
            } catch (e) {
                errorResolver(e, next);
            }
        } catch (e) {
            errorResolver(e, next);
        }
    }
};


module.exports.createClient = async (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        validationResolver(errors.array(), next);
    } else {

        const { client_url } = req.body;

        const newClient = {
            response_type: req.body.response_type ? req.body.response_type : 'code',
            client_url,
        };

        try {
            await Client.init();
            const { _doc: data } = await Client.create(newClient);
            successResolver(res, {
                data,
                message: 'Client created!',
            });
        } catch (e) {
            errorResolver(e, next);

        }
    }
};

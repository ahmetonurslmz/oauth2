const { errorResolver, successResolver, validationResolver } = require('../../../core/utils/resolvers');
const { validationResult } = require('express-validator');
const Client = require('../models/ClientModel');

const { findOrThrow } = require('../../../core/utils/mongoInterrogator');


const HashGeneratorService = require('../../../core/services/hashGenerator.service');
const JWTGeneratorService = require('../../../core/services/jwtGenerator.service');


module.exports.generateServerKeys = async (req, res) => {
    const crypto = require('crypto');
    const { privateKey, publicKey } = crypto.generateKeyPairSync('rsa', {
        modulusLength: 2048,
        publicKeyEncoding: {
            type: 'spki',
            format: 'pem'
        },
        privateKeyEncoding: {
            type: 'pkcs8',
            format: 'pem'
        }
    });

    const fs = require('fs');
    fs.writeFile('id_rsa_priv.pem', privateKey, 'utf8', function (err) {
        if (err) return console.log(err);
        console.log('id_rsa_priv.pem was generated.');
    });


    fs.writeFile('id_rsa_pub.pem', publicKey, 'utf8', function (err) {
        if (err) return console.log(err);
        console.log('id_rsa_pub.pem was generated');
    });

    successResolver(res, {
        message: 'Server keys generated!',
    });
};


module.exports.verifyAccessToken = async (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        validationResolver(errors.array(), next);
    } else {
        successResolver(res, {
            message: 'Access token is valid!',
        });
    }
};

/**
 * Works for only authorization code grant type
 * @param req
 * @param res
 * @param next
 * @returns {Promise<void>}
 */
module.exports.getAccessToken = async (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        validationResolver(errors.array(), next);
    } else {
        const { client_id, code, grant_type } = req.body;

        try {
            if (grant_type === 'authorization_code') {

                await Client.init();
                const requestedClient = await findOrThrow(Client, { _id: client_id, is_active: true });

                if (req.hostname === 'localhost' || requestedClient.client_url === req.hostname) {

                    const AuthorizationCode = require('../models/AuthorizationCodeModel');
                    await AuthorizationCode.init();

                    const AccessToken = require('../models/AccessTokenModel');
                    await AccessToken.init();

                    let authorizationCodeData;
                    try {
                        authorizationCodeData = await findOrThrow(AuthorizationCode, {
                            code,
                            client_id,
                            is_active: true,
                            expiry_date: { $gt: new Date() } // if expiry date is higher than now date.
                        });
                    } catch (e) {
                        // checks whether authorization code exists or not.
                        const { _id: authorization_code_id } = await findOrThrow(AuthorizationCode, { code });

                        // controls whether access token that generated by authorization code exists or not
                        const hasAccessToken = AccessToken.findOne({ authorization_code_id });
                        if (hasAccessToken) {
                            // disables access token that generated by authorization code to prevent attacks
                            await AccessToken.updateOne({ authorization_code_id }, { is_active: false });
                        }
                        throw e;
                    }

                    // generates access token
                    const jwtTokenInstance = new JWTGeneratorService();
                    const access_token = jwtTokenInstance.sign();

                    // generates refresh token
                    jwtTokenInstance.payload = jwtTokenInstance.getDateInformation(true);
                    const refresh_token = jwtTokenInstance.sign();

                    const newAccessToken = {
                        authorization_code_id: authorizationCodeData._id,
                        client_id,
                        grant_type,
                        access_token,
                        refresh_token,
                    };

                    const { _doc } = await AccessToken.create(newAccessToken);


                    // disable authorization code
                    await AuthorizationCode.updateOne({ code }, { is_active: false });

                    successResolver(res, {
                        data: {
                            access_token,
                            token_type: _doc.token_type,
                            expires_in: _doc.expires_in,
                            refresh_token,
                        },
                        message: 'Access token generated!',
                    });
                } else {
                    const e = new Error();
                    e.message = 'Invalid client!';
                    e.code = 403;
                    throw e;
                }
            } else {
                const e = new Error();
                e.message = 'The grant type is not supported yet!';
                e.code = 403;
                throw e;
            }
        } catch (e) {
            errorResolver(e, next);
        }
    }
};


module.exports.getAuthorizationCode = async (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        validationResolver(errors.array(), next);
    } else {
        const { client_id, response_type } = req.body;

        try {
            await Client.init();
            const requestedClient = await findOrThrow(Client, { _id: client_id, response_type, is_active: true });

            if (req.hostname === 'localhost' || requestedClient.client_url === req.hostname) {

                const HashGeneratorServiceInstance = new HashGeneratorService();
                const hash = HashGeneratorServiceInstance.generate();


                const AuthorizationCode = require('../models/AuthorizationCodeModel');
                await AuthorizationCode.init();

                const PERIOD_OF_VALIDITY = 10; // minutes

                // generates authorization code's expiry date by adding period of validity minutes to now date.
                const expiry_date = new Date();
                expiry_date.setMinutes(expiry_date.getMinutes() + PERIOD_OF_VALIDITY);


                const newAuthorizationCode = {
                    client_id,
                    code: hash,
                    expiry_date,
                };

                try {
                    const { _doc } = await AuthorizationCode.create(newAuthorizationCode);
                    successResolver(res, {
                        data: _doc,
                        message: 'Authorization code generated!',
                    });
                } catch (e) {
                    errorResolver(e, next);
                }
            } else {
                const e = new Error();
                e.message = 'Invalid client!';
                e.code = 403;
                throw e;
            }
        } catch (e) {
            errorResolver(e, next);
        }
    }
};


module.exports.createClient = async (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        validationResolver(errors.array(), next);
    } else {

        const { client_url } = req.body;

        const newClient = {
            response_type: 'code',
            client_url,
        };

        try {
            await Client.init();
            const { _doc: data } = await Client.create(newClient);
            successResolver(res, {
                data,
                message: 'Client created!',
            });
        } catch (e) {
            errorResolver(e, next);

        }
    }
};

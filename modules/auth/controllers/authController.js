const {
    errorResolver,
    successResolver,
    validationResolver,
} = require('../../../core/utils/resolvers');
const { validationResult } = require('express-validator');

const { findOrThrow } = require('../../../core/utils/mongoInterrogator');

const HashGeneratorService = require('../../../core/services/hashGenerator.service');
const JWTGeneratorService = require('../../../core/services/jwtGenerator.service');
const JwtVerificationService = require('../../../core/services/jwtVerification.service');

const validateClient = require('../../client/services/validateClient.service');
const validateEntriesService = require('../../../core/services/validateEntries.service');

module.exports.verifyAccessToken = async (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        validationResolver(errors.array(), next);
    } else {
        try {
            const verificationInstance = new JwtVerificationService(
                req.body.access_token
            );
            const payload = verificationInstance.decrypt();

            // Today date is smaller than expiration date so that access token is valid.
            if (new Date().getTime() - payload.exp < 0) {
                const active = verificationInstance.verify();

                successResolver(res, {
                    data: {
                        active,
                        ...payload,
                    },
                });
            } else {
                const e = new Error();
                e.message = 'Access token has been expired!';
                e.field = 'access_token';
                e.code = 400;
                throw e;
            }
        } catch (e) {
            errorResolver(e, next);
        }
    }
};

/**
 * Works for both authorization code and password grant types
 * @param req
 * @param res
 * @param next
 * @returns {Promise<void>}
 */
module.exports.getAccessToken = async (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        validationResolver(errors.array(), next);
    } else {
        const { client_id, grant_type } = req.body;

        try {
            if (grant_type === 'authorization_code') {
                await validateClient(req, client_id, 'code');

                validateEntriesService('code', req);

                const { code } = req.body;

                const AuthorizationCode = require('../models/AuthorizationCodeModel');
                await AuthorizationCode.init();

                const AccessToken = require('../models/AccessTokenModel');
                await AccessToken.init();

                let authorizationCodeData;
                try {
                    authorizationCodeData = await findOrThrow(
                        AuthorizationCode,
                        {
                            code,
                            client_id,
                            is_active: true,
                            expiry_date: { $gt: new Date() }, // if expiry date is higher than now date.
                        }
                    );
                } catch (e) {
                    // checks whether authorization code exists or not.
                    const {
                        _id: authorization_code_id,
                    } = await findOrThrow(AuthorizationCode, { code });

                    // controls whether access token that generated by authorization code exists or not
                    const hasAccessToken = AccessToken.findOne({
                        authorization_code_id,
                    });
                    if (hasAccessToken) {
                        // disables access token that generated by authorization code to prevent attacks
                        await AccessToken.updateOne(
                            { authorization_code_id },
                            { is_active: false }
                        );
                    }
                    throw e;
                }

                // generates access token
                const jwtTokenInstance = new JWTGeneratorService();
                const access_token = jwtTokenInstance.sign();

                // generates refresh token
                jwtTokenInstance.payload = jwtTokenInstance.getDateInformation(
                    true
                );
                const refresh_token = jwtTokenInstance.sign();

                const newAccessToken = {
                    authorization_code_id: authorizationCodeData._id,
                    client_id,
                    grant_type,
                    access_token,
                    refresh_token,
                };

                const { _doc } = await AccessToken.create(newAccessToken);

                // disable authorization code
                await AuthorizationCode.updateOne(
                    { code },
                    { is_active: false }
                );

                successResolver(res, {
                    data: {
                        access_token,
                        token_type: _doc.token_type,
                        expires_in: _doc.expires_in,
                        refresh_token,
                    },
                    message: 'Access token generated!',
                });
            } else if (grant_type === 'password') {
                await validateClient(req, client_id, 'token');

                validateEntriesService(['username', 'password'], req);

                // Resource server control
                const { username, password } = req.body;

                // generates access token
                const jwtTokenInstance = new JWTGeneratorService();
                jwtTokenInstance.payload = { username };

                const access_token = jwtTokenInstance.sign();

                // generates refresh token
                jwtTokenInstance.payload = {
                    username,
                    ...jwtTokenInstance.getDateInformation(true),
                };
                const refresh_token = jwtTokenInstance.sign();

                const newAccessToken = {
                    authorization_code_id: null,
                    client_id,
                    grant_type,
                    access_token,
                    refresh_token,
                };

                const AccessToken = require('../models/AccessTokenModel');
                await AccessToken.init();

                const { _doc } = await AccessToken.create(newAccessToken);

                successResolver(res, {
                    data: {
                        access_token,
                        token_type: _doc.token_type,
                        expires_in: _doc.expires_in,
                        refresh_token,
                    },
                    message: 'Access token generated!',
                });
            } else {
                const e = new Error();
                e.message = 'The grant type is not supported yet!';
                e.code = 403;
                throw e;
            }
        } catch (e) {
            errorResolver(e, next);
        }
    }
};

module.exports.chooseAccount = async (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        validationResolver(errors.array(), next);
    } else {
        try {
            const { client_id, redirect_url } = req.query;
            await validateClient(req, client_id, 'code', {
                client_url: redirect_url,
            });
            res.render('login');
        } catch (e) {
            res.render('invalidClient');
        }
    }
};

module.exports.getAuthorizationCode = async (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        validationResolver(errors.array(), next);
    } else {
        const { client_id, redirect_url } = req.body;

        try {
            await validateClient(req, client_id, 'code', {
                client_url: redirect_url,
            });
            const HashGeneratorServiceInstance = new HashGeneratorService();
            const hash = HashGeneratorServiceInstance.generate();

            const AuthorizationCode = require('../models/AuthorizationCodeModel');
            await AuthorizationCode.init();

            const PERIOD_OF_VALIDITY = 10; // minutes

            // generates authorization code's expiry date by adding period of validity minutes to now date.
            const expiry_date = new Date();
            expiry_date.setMinutes(
                expiry_date.getMinutes() + PERIOD_OF_VALIDITY
            );

            const newAuthorizationCode = {
                client_id,
                code: hash,
                expiry_date,
            };

            try {
                const { _doc } = await AuthorizationCode.create(
                    newAuthorizationCode
                );

                successResolver(res, {
                    data: _doc,
                    message: 'Authorization code generated!',
                });
            } catch (e) {
                errorResolver(e, next);
            }
        } catch (e) {
            errorResolver(e, next);
        }
    }
};
